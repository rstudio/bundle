% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{has_bundler}
\alias{has_bundler}
\alias{has_bundler.workflow}
\alias{has_bundler.model_fit}
\alias{has_bundler.recipe}
\alias{has_bundler.default}
\alias{has_bundler.bundle}
\alias{has_bundler.model_spec}
\title{Check whether an object has a bundling method}
\usage{
has_bundler(x)

\method{has_bundler}{workflow}(x)

\method{has_bundler}{model_fit}(x)

\method{has_bundler}{recipe}(x)

\method{has_bundler}{default}(x)

\method{has_bundler}{bundle}(x)

\method{has_bundler}{model_spec}(x)
}
\arguments{
\item{x}{A model object to bundle.}
}
\value{
A logical.
}
\description{
Given a model object, this function will return whether the object
will dispatch to a non-trivial bundler. For most objects, \code{has_bundler()}
simply returns whether the object will dispatch to \code{bundle.default()}, the
identity function. For some objects, whose bundling methods recurse into
elements of the inputted object, \code{has_bundler()} returns whether the
final dispatch to a \code{bundle()} method is \code{bundle.default()} for \emph{all} of
the recursed elements. More plainly---if bundling an object \code{x} will make a
call to native serialization methods anywhere inside its interals,
\code{has_bundler(x)} will return \code{TRUE}.

Note that a return value of \code{FALSE} does not necessarily mean that
the object \code{x} cannot be saved and re-loaded in a new session---many model
objects, like \code{\link[stats:lm]{stats::lm()}} and \code{\link[stats:glm]{stats::glm()}} output, can be effectively
saved and re-loaded in a new session without any bundling.
}
\seealso{
\code{\link[=bundle]{bundle()}}, \code{\link[=unbundle]{unbundle()}}
}
